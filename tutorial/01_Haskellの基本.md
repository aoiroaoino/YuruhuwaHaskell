# Haskellの基本 #
Tutorial for ゆるふわHaskell入門会

-----------------------------------------

### GHCiを電卓替わりに使う ###
#### 四則演算 ####
GHCiに数式を入力すると、その計算結果がすぐに返ってきます。
```
Prelude> 1 + 1
2
Prelude> 2 * 3
6
Prelude> 10 - 3
7
Prelude> 10 / 2
5.0
```
#### 論理演算 ####
論理演算の演算子は、以下のとおりです。
```
ghci> 1 == 1
True
Prelude> 9 == 9
True
Prelude> 9 /= 9
False
Prelude> 1 <= 5
True
Prelude> 3 < 1
False
Prelude> 4 >= 4
True
Prelude> 5 > 7
False
```
#### 演算子と優先順位 ####
乗算、除算は加減算より優先されます
```
Prelude> 1 + 2 * 3
7
Prelude> 10 - 6 / 2
7.0
```
かっこでくった計算は優先されます
```
Prelude> (1 + 2) * 3
9
Prelude> (10 - 6) / 2
2.0
```
#### 関数呼び出し ####
関数呼出しは hoge(x)ではなく、半角スペースで区切って hoge x のように書きます。
```
Prelude> succ 5
6
Prelude> max 5 5
5
Prelude> max 4 6
6
Prelude> min 6 2
2
Prelude> not True
False
Prelude> max (5 * 2) (6 + 3)
10
```
関数摘要は常に最優先で計算されます。
```
Prelude> min 2 5 * max 3 10
20
```
####演算子の中置記法／関数の前置記法
Haskellの「演算子」は実際の所「中置記法の関数」に過ぎません。  
次のようにして、中置関数を普通の関数のように前置したり、逆に`max`のような普通の関数を、中置記法で書くこともできます。
```
Prelude> 11 + 23
34
Prelude> (+) 11 23
34
Prelude> max 8 15
15
Prelude> 8 `max` 15
15
```
-----------------------------------------

### 関数の作成 ###
#### Haskellのソースコードの書き方 ####
```haskell
--これは一行コメント
--無視されます

{- 
これは
複数行にわたる
コメント

無視されます
-}

--関数名／束縛変数名は小文字ではじめます
toPare a = (a, a)

--データコンストラクタは大文字ではじめます
--TrueやFalseはデータコンストラクタです
isZero 0 = True
isZero _ = False

--型クラス名／型名は大文字、型変数名は小文字ではじめます
--※ 以下のサンプルでは、Eq, Numが型クラス、Boolが型名、そしてaが型変数です
--　 後でちゃんと説明するので、今は解らなくても良いです
hoge :: (Eq a, Num a) => a -> a -> Bool
hoge x y = x == x * 2

--一行が長くなる場合は、インデントする事で前の行の続きである事を表します
qsort [] = []
qsort (x:xs) =
  qsort [y | y <- xs, y <= x] ++ 
  [x] ++ qsort [z | z <- xs, x < z]

--上の例は、以下のように二行で書き下すのと一緒です
qsort [] = []
qsort (x:xs) = qsort [y | y <- xs, y <= x] ++ [x] ++ qsort [z | z <- xs, x < z]
```

|要素                |大文字or小文字|例     |
|--------------------|--------------|-------|
|パッケージ名        |大文字        |Prelude|
|型                  |大文字        |Integer|
|型クラス            |大文字        |Num    |
|型変数              |小文字        |a      |
|データコンストラクタ|大文字        |True   |
|変数                |小文字        |x      |
|関数                |小文字        |min    |

色々と細々とした約束事を書きましたが、書いていくうちに覚えるので、今はなんとなくで構いません。
大文字ではじまるか、小文字ではじまるかで意味が変わる事だけ覚えておきましょう。
#### Haskellのソースファイルを読み込む ####
Haskellのソースファイルの拡張子は *.hs です。  
以下のソースコードを、適当なファイル名で保存してみましょう。
```haskell
--基本的な宣言の仕方
dbl x = x * 2

--引数を二つ取る関数
add x y = x + y

--引数を取らない関数
five = 5
```
引数として受け取る値が入る変数の事を「束縛変数」と言います。
また、`x`という束縛変数に5という値が入る事を、「xが5に束縛される」あるいは「5がxを束縛する」と言います。

ghci起動時に、ファイル名を引数で渡す事によって、ロードする事ができます。
```
% ghci Sample01.hs
GHCi, version 7.6.1: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( Sample01.hs, interpreted )
Ok, modules loaded: Main.
```
既に起動したghciから ":l [ファイル名]" とコマンド入力してもロードできます。
```
Prelude> :l Sample01.hs
[1 of 1] Compiling Main             ( Sample01.hs, interpreted )
Ok, modules loaded: Main.
*Main> 
```
ファイルがロードできたら、定義した関数が使えるようになっている事を確認してみましょう。
```haskell
*Main> dbl 10
20
*Main> add 5 10
15
*Main> five
5

```
#### GHCiで関数を宣言 ####
GHCiで一時的な小さな関数を定義したい場合は、letを使います。
```
Prelude> let dbl x = x * 2
Prelude> let add x y = x + y
Prelude> let five = 5
```
GHCiを終了するまで使う事ができます。
```haskell
Prelude> add (dbl 5) (dbl 3)
16
```
-----------------------------------------

### リストの基本 ###
#### 基本的なシンタックス ####
リストは以下のように、[ ]の中を","で区切って表現します。 
```haskell
Prelude> [1, 2, 3]
[1,2,3]
Prelude> [True, False, False]
[True,False,False]
```

#### 文字列は文字のリスト ####
Haskellでは文字をシングルクォート ' ' で囲って表現します。
```haskell
Prelude> 'a'
'a'
Prelude> 'b'
'b'
Prelude> 'c'
'c'
```
文字列は、文字のリストとして表します。
```haskell
Prelude> ['a', 'b', 'c']
"abc"
Prelude> ['d', 'e', 'f']
"def"
```

" " でくくって文字列を表現する事もできます。
ただのシンタックスシュガーなので、"abc" と ['a','b','c'] はまったく同じものです。
```haskell
Prelude> "abc"
"abc"
Prelude> "def"
"def"
Prelude> "abc" == ['a', 'b', 'c']
True
```

#### リストを操作する関数 ####
```haskell
Prelude> take 3 [1, 2, 4, 8, 16]
[1,2,4]
Prelude> drop 3 [1, 2, 4, 8, 16]
[8,16]
Prelude> sum [1, 2, 4, 8, 16]
31
Prelude> product [1, 2, 4, 8, 16]
1024
```
#### なるべく使いたくない関数＆演算子 ####
```
Prelude> head [1, 2, 4, 8, 16]
1
Prelude> tail [1, 2, 4, 8, 16]
[2,4,8,16]
Prelude> [1, 2, 4, 8, 16] !! 3
8
```
エラーが発生する可能性がある関数は、Haskellでは避けられる傾向があります。  
何故なら、予期しないエラーにより処理が中断してしまったり、無限ループに入ってしまうバグは、型によって防ぐことができないからです。  
上で紹介した関数は、パラーメターが不正だとエラーが発生する可能性があるので、できれば使いたく無い関数です。
```haskell
Prelude> head []
*** Exception: Prelude.head: empty list
Prelude> tail []
*** Exception: Prelude.tail: empty list
Prelude> [1, 2, 4, 8, 16] !! 6
*** Exception: Prelude.(!!): index too large
```
#### 連続したリストを一気に作る ####
連続したリストは以下のようにして ".." で一気に作る事ができます。
```haskell
Prelude> [1..5]
[1,2,3,4,5]
Prelude> [1..10]
[1,2,3,4,5,6,7,8,9,10]
Prelude> [2,4..10]
[2,4,6,8,10]
Prelude> ['a'..'g']
"abcdefg"
Prelude> ['a','c'..'k']
"acegik"
```
Haskellは、無限の長さのリストを作る事もできます。
```haskell
Prelude> [1..]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44...
```
```haskell
Prelude> [2,4..]
[2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86...
```
無限の長さのリストは、`take` `drop`と組み合わせて使うと便利です。
```haskell
Prelude> take 10 (drop 5 [2,4..])
[12,14,16,18,20,22,24,26,28,30]
```
無限の長さを返す関数もあります。
```haskell
Prelude> cycle [1,2,3]
[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1...
```
```haskell
Prelude> repeat 5
[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
```
実は、`cycle`関数も例外を返す関数です。  
```haskell
Prelude> cycle []
*** Exception: Prelude.cycle: empty list

```
#### リスト内包表記 ####
ちょと複雑な数列やリストを生成するのに、リスト内包表記を使うと便利です。
```haskell
Prelude> [x * 2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```
`[1..100]`のうち、3で割り切れる数を2倍した数のリスト...のような数列も、リスト内包表記なら簡単に作れます。  
ここで、`mod`は剰余を計算する関数です。
```haskell
Prelude> [x * 2 | x <- [1..100], x `mod` 3 == 0]
[6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198]
```

(問)
以下は、引数が素数だった場合`True`を返す関数です。

これを使って、1〜100までの素数のリストを作成してみてください。  
また、1〜の素数を全て列挙する無限リストを作成する関数`prims`を作成してみてください。
```haskell
let isPrime x = if x < 2 then False else not (or [mod x y == 0 | y <- [2..div x 2]])
```
-----------------------------------------

### タプルを使う ###
#### タプルの基本 ####
複数の組みを扱うには、タプルが便利です。  
タプルは`( )`の中を`,`で区切って表します。
```haskell
Prelude> (1, 2, 3)
(1,2,3)
Prelude> ("hoge", "piyo", "huga")
("hoge","piyo","huga")
```
タプルはパッと見リストと似ていますが、リストが一つの型しか受け付けないのに対し、タプルは複数の型を混ぜて使う事ができます。
```haskell
Prelude> (1, "hoge", True)
(1,"hoge",True)
```
####ペアを使う
タプルの中でも、２要素のタプルは特別よく使われます。
そのため、ペア専用には`fst`と`snd`という、要素を取り出すための特別な型が用意されています。
```haskell
Prelude> fst (1, True)
1
Prelude> fst ("hoge", 'x')
"hoge"
Prelude> snd ("piyo", False)
False
Prelude> snd ('y', 99)
99
```
`zip`関数は二つのリストを元に、ペアのリストを作る関数です。
```haskell
Prelude> zip [1,2,3] [10,20,30]
[(1,10),(2,20),(3,30)]
Prelude> zip [2,4,6] ["abc","def","ghi"]
[(2,"abc"),(4,"def"),(6,"ghi")]
```
`zip`関数の結果の長さは、短いほうのリストに合せられます。
```haskell
Prelude> zip ["hoge", "piyo", "huga", "hogera", "hogehoge"] ['h', 'p', 'h']
[("hoge",'h'),("piyo",'p'),("huga",'h')]
Prelude> zip [2,3,1,8] "tune ha ikemen"
[(2,'t'),(3,'u'),(1,'n'),(8,'e')]
```
この事を利用し、リストの要素に番号を振るnumbering関数は以下のようにして簡単に実装できます。
```haskell
Prelude> let numbering xs = zip [1..] xs
Prelude> numbering ["hoge", "piyo", "huga"]
[(1,"hoge"),(2,"piyo"),(3,"huga")]
```
#### タプル×リスト内包表記 ####
タプルを使うことによって、リスト内包表記の面白い機能を見ることができます。
以下のように、複数のリストの全ての組み合わせパターンを作ることができるのです。
```haskell
Prelude> [(x, y)| x <- [1,2,3], y <- [10,20,30]]
[(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30)]
Prelude> [(x, y, z)| x <- [1,2,3], y <- [10,20,30], z <- [100,200,300]]
[(1,10,100),(1,10,200),(1,10,300),(1,20,100),(1,20,200),(1,20,300),(1,30,100),(1,30,200),(1,30,300),(2,10,100),(2,10,200),(2,10,300),(2,20,100),(2,20,200),(2,20,300),(2,30,100),(2,30,200),(2,30,300),(3,10,100),(3,10,200),(3,10,300),(3,20,100),(3,20,200),(3,20,300),(3,30,100),(3,30,200),(3,30,300)]
```
この機能と、先ほどの素数判定関数を組み合わせて使う事によって、1〜10の間で、足した結果が素数になる全ての組み合わせを計算する事ができます。
```haskell
Prelude> [(x + y,(x, y))| x <- [2..10], y <- [2..10], isPrime (x + y)]
[(5,(2,3)),(7,(2,5)),(11,(2,9)),(5,(3,2)),(7,(3,4)),(11,(3,8)),(13,(3,10)),(7,(4,3)),(11,(4,7)),(13,(4,9)),(7,(5,2)),(11,(5,6)),(13,(5,8)),(11,(6,5)),(13,(6,7)),(11,(7,4)),(13,(7,6)),(17,(7,10)),(11,(8,3)),(13,(8,5)),(17,(8,9)),(11,(9,2)),(13,(9,4)),(17,(9,8)),(19,(9,10)),(13,(10,3)),(17,(10,7)),(19,(10,9))]
```