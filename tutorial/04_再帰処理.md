#再帰処理
Tutorial for ゆるふわHaskell入門会

-----------------------------------------

関数型言語の入門サイトなんかで、良く「関数プログラミングではループの代わりに再帰を使います。」と言われるため、「関数プログラミングと言えば再帰」のような位置づけに感じている方も居るかもしれません。  
確かに、関数プログラミングで繰り返し処理を実現する基本的な手段なのは確かですが、少なくともHaskellにおいて再帰処理を極める事は、あまり重要ではありませんし、それほど述べる事があるわけでもありません。  
実際、「凄いHaskell楽しく学ぼう」の原書であるLearn You a Haskell for Great Good!でも、再帰処理について述べられているChapter 4はそれほどページを割かれていなかったりします。

|Chapter|Title                |Page|
|-------|---------------------|----|
|3      |Sytax in Functions   |12  |
|4      |Hello Recursion!     |8   |
|5      |Highe-Order Functions|28  |

そんなワケで、この勉強会ではさらに思い切って、少しの具体例だけ示したら、次に進むつもりでいます。  

-----------------------------------------

###再帰の練習

与えられた引数の階乗を計算する関数を考えてみましょう。  
一番代表的な階乗の計算方法は、次のようにして再帰的に自分を呼び出す関数を定義する事です。
```haskell
fractional :: (Eq a, Num a) => a -> a
fractional 1 = 1
fractional x = x * fractional (x - 1)
```
まぁ、次のようにproduct関数を使っちゃえば良いんですけどね。
```haskell
fractional :: (Enum a, Num a) => a -> a
fractional x = product [1..x]
```

また、少し高度ですが、`(:)`という演算子が、「リストの先頭に要素を追加する演算」という事を知っていれば...
```
*Main> :t (:)
(:) :: a -> [a] -> [a]
*Main> 1:[2,3]
[1,2,3]
*Main> 1:2:3:[] --右結合の演算子なのでこんな書き方もできる
[1,2,3]
```
次のようにして、階乗のリストを一気に作る事ができたりします。
```haskell
fractoList :: [Integer]
fractoList =  f 1 [1..]
  where
    f :: Integer -> [Integer] -> [Integer]
    f v (x:xs) = let n = v * x in n : f n xs
```
もう一つ、zip関数の実装が良い例なので、載せておきます。
```haskell
myzip :: [a] -> [b] -> [(a, b)]
myzip [] _ = []
myzip _ [] = []
myzip (x:xs) (y:ys) = (x, y) : myzip xs ys
```
####ちょっとだけ形式的な話を...
再度、階乗計算の関数を下に示します。
```haskell
fractional :: (Eq a, Num a) => a -> a
fractional 1 = 1
fractional x = x * fractional (x - 1)
```
ここで、一つ目のパターン...引数が 1 だったら 1を返す部分が、再帰計算の終点になるわけですが、再帰処理のこのパターンを「基底部」と言います。  
そして、実際に関数が「自分自身を呼び出しているパターン」を「再帰部」と言います。

通常、無限リストを作ったり、副作用を起こしながら無限再帰させたりする場合を除いて、再帰関数には必ず「再帰部」が必要です。  
再帰関数について話をする時に、知っておく必要のある言葉なので、覚えておきましょう。

-----------------------------------------

###悪名高きクイックソート

さて、チュートリアルをここまで進めてきた我々は、最初のほうで少しだけお見せしたクイックソートの実装を読むことができます。  
先に述べた通り、再帰は基本的に時間を割くほどの題材では無いので、これを解読したら終わりにしましょう。
```haskell
qsort :: Ord a => [a] -> [a]
qsort [] = []
qsort (x:xs) = qsort [y | y <- xs, y <= x] ++ [x] ++ qsort [z | z <- xs, x < z]
```
(++)演算子のコストが高いので、このクイックソートはそんなに早くないんですけどねっ☆（ゝω・）vｷｬﾋﾟ

-------------------------------------------------

時間があったらここでHoogleの説明をします